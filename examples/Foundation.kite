--- Functional

-- a -> a
id = |x| -> { x }

-- composition
-- (b -> c) -> (a -> b) -> (a -> c)
{.} = |f, g| -> {
  |x| -> {
    f (g (x))
  }
}

-- (a -> b -> c) -> (b -> a -> c)
flip = |f, x, y| -> {
  f (y, x)
}

--- Boolean

-- Bool -> Bool
not = |p| -> {
  if p then False else True
}

-- Bool -> Bool -> Bool
{&&} = |l, r| -> {
  if l then r else False
}

-- Bool -> Bool -> Bool
{||} = |l, r| -> {
  if l then True else r
}

--- Equality (built in: ==)

-- a -> a -> Bool
{/=} = |l, r| -> {
  not (l == r)
}

--- Ordering (built in: <=)

-- a -> a -> Bool
{<} = |l, r| -> {
  not (r <= l)
}

-- a -> a -> Bool
{>} = |l, r| -> {
  (r <= l) && (r /= l)
}

-- a -> a -> Bool
{>=} = |l, r| -> {
  (l > r) || (l == r)
}

--- Lists

-- [a] -> Bool
empty = |xs| -> {
  length (xs) == 0
}

-- [a] -> a
head = |xs| -> {
  xs # 0
}

-- [a] -> [a]
tail = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 1, length (xs))
}

-- [a] -> a
last = |xs| -> {
  if length (xs) == 1
    then head (xs)
    else (last . tail) (xs)
}

-- concatenation
-- [a] -> [a] -> [a]
{++} = |l, r| -> {
  if empty (l)
    then r
    else head (l) : (tail (l) ++ r)
}

-- [a] -> [a]
init = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 0, length (xs) - 1)
}

-- (a -> b) -> [a] -> [b]
map = |f, xs| -> {
  if empty (xs)
    then []
    else f (head (xs)) : map (f, tail (xs))
}

-- (a -> b -> a) -> a -> [b] -> a
fold = |f, acc, xs| -> {
  if empty (xs)
    then acc
    else fold (f, f (acc, head (xs)), tail (xs))
}

-- (a -> b -> a) -> [b] -> a
fold1 = |f, xs| -> {
  if empty (xs)
    then head (xs) -- TODO: needs an error function
    else fold (f, head (xs), tail (xs))
}

-- (a -> Bool) -> [a] -> [a]
filter = |f, xs| -> {
  if empty (xs)
    then []
    else if f (head (xs))
           then head (xs) : filter (f, tail (xs))
           else filter (f, tail (xs))
}

-- Int -> [a] -> [a]
take = |n, xs| -> {
  if (n <= 0) || empty (xs)
    then []
    else head (xs) : take (n - 1, tail (xs))
}

-- Int -> [a] -> [a]
drop = |n, xs| -> {
  if (n <= 0) || empty (xs)
    then xs
    else drop (n - 1, tail (xs))
}

-- [Bool] -> Bool
and = |xs| -> {
  fold ((&&), True, xs)
}

-- [Bool] -> Bool
or = |xs| -> {
  fold ((||), False, xs)
}

-- (a -> Bool) -> [a] -> Bool
all = |p, xs| -> {
  (and . map (p)) (xs)
}

-- (a -> Bool) -> [a] -> Bool
any = |p, xs| -> {
  (or . map (p)) (xs)
}

-- [[a]] -> [a]
flatten = |xs| -> {
  fold1 ((++), xs)
}

-- a -> [a] -> Bool
contains = |xs, el| -> {
  any ((== el), xs)
}

-- [a] -> [a]
reverse = |xs| -> {
  if empty (xs)
    then []
    else (reverse . tail) (xs) ++ [head (xs)]
}

-- union, intersect, takeWhile, dropWhile, find, delete, deleteBy
union = |xs, xs'| -> {
  f = |acc, x| -> {
    if acc `contains x
      then acc
      else x : acc
  }
  fold (f, xs', xs)
}

intersect = |xs, xs'| -> {
  f = |acc, x| -> {
    if xs `contains x
      then x : acc
      else acc
  }
  fold (f, [], xs')
}

-- quicksort
-- [a] -> [a]
sort = |xs| -> {
  if empty (xs)
    then []
    else sort (filter ((head (xs) <), tail (xs)))
         ++ head (xs)
         : sort (filter ((head (xs) >=), tail (xs)))
}

--- List utilities

-- Int -> Int -> Int -> [Int]
rangeStep = |from, to, step| -> {
  inner = |from, to, ls| -> {
    if from > to
      then ls
      else from : inner (from + step, to, ls)
  }
  inner(from, to, [])
}

-- Int -> Int -> [Int]
range = |from, to| -> {
  rangeStep (from, to, 1)
}

--- Numeric

-- Float -> Float
-- sqrt = |n| -> {
--   x0 = if n < 10 then 200.0 else 600.0
--   inner = |i, n'| -> {

--   }
--   inner
-- }

-- Int -> Int -> Int
{^} = |n, exp| -> {
  if exp == 0
    then 1
    else n * n ^ (exp - 1)
}

-- [a] -> a
sum = |xs| -> {
  fold1 ((+), xs)
}

-- [a] -> a
product = |xs| -> {
  fold1 ((*), xs)
}

-- a -> a -> a
min = |a, b| -> {
  if a < b then a else b
}

-- a -> a -> a
max = |a, b| -> {
  if a > b then a else b
}

-- [a] -> a
minimum = |xs| -> {
  fold1 (min, xs)
}

-- [a] -> a
maximum = |xs| -> {
  fold1 (max, xs)
}

-- Int -> Bool
even = (== 0) . (% 2)

-- Int -> Bool
odd = not . even

-- Int -> Int
negate = |n| -> {
  0 - n
}

-- Int -> Int
abs = |n| -> {
  if n < 0
    then negate (n)
    else n
}

--- Misc

-- (a -> Bool) -> (a -> a) -> a -> a
until = |p, f, x| -> {
  if p (x)
    then x
    else until (p, f, f (x))
}

-- (a -> Bool) -> (a -> a) -> a -> a
while = |p, f, x| -> {
  until (not . p, f, x)
}