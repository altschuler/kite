

-- functional
id = |x| -> { x }

compose = |f, g| -> {
  |x| -> { 
    f (g (x)) 
  }
}

flip = |f, x, y| -> {
  f (y, x)
}

not = |p| -> {
  if p then False else True
}

-- misc
until = |p, f, x| -> {
  if p (x)
    then x
    else until (p, f, f (x))
}

while = |p, f, x| -> {
  until (not `compose p, f, x)
}

-- list functions
empty = |xs| -> {
  length (xs) == 0
}

head = |xs| -> {
  xs # 0
}

tail = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 1, length (xs))
}

last = |xs| -> {
  if length (xs) == 1
    then last (tail (xs))
    else head (xs)
}

init = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 0, length (xs) - 1)
}

map = |f, xs| -> {
  if empty (xs)
    then []
    else [f (head (xs))] ++ map (f, tail (xs))
}

fold = |f, acc, xs| -> {
  if empty (xs)
    then acc
    else fold (f, f (acc, head (xs)), tail (xs))
}

fold1 = |f, xs| -> {
  if empty (xs)
    then head (xs) -- TODO: needs an error function
    else fold (f, head (xs), tail (xs))
}

filter = |f, xs| -> {
  if empty (xs)
    then []
    else if f (head (xs))
           then [head (xs)] ++ filter (f, tail (xs))
           else filter (f, tail (xs))
}

take = |n, xs| -> {
  if (n <= 0) || empty (xs)
    then []
    else [head (xs)] ++ take (n - 1, tail (xs))
}

drop = |n, xs| -> {
  if (n <= 0) || empty (xs)
    then xs
    else drop (n - 1, tail (xs))
}

and = |xs| -> {
  fold ((&&), True, xs)
}

or = |xs| -> {
  fold ((||), False, xs)
}

all = |p, xs| -> {
  (and `compose map (p)) (xs)
}

any = |p, xs| -> {
  (or `compose map (p)) (xs)
}

flatten = |xs| -> {
  fold1 ((++), xs)
}

contains = |el, xs| -> {
  any ((==)(el), xs)
}

rangeStep = |from, to, step| -> {
  inner = |from, to, ls| -> {
    if from > to
      then ls
      else [from] ++ inner (from + step, to, ls)
  }
  inner(from, to, [])
}

range = |from, to| -> {
  rangeStep (from, to, 1)
}

reverse = |xs| -> {
  if empty (xs)
    then []
    else reverse (tail (xs)) ++ [head (xs)]
}

-- quicksort
sort = |xs| -> {
  if empty (xs)
    then []
    else sort (filter (flip ((<)) (head (xs)), tail (xs)))
         ++ [head (xs)]
         ++ sort (filter (flip ((>=)) (head (xs)), tail (xs)))
}

-- numeric
sum = |xs| -> {
  fold (|acc, n| -> { acc + n }, 0, xs)
}

product = |xs| -> {
  fold (|acc, n| -> { acc * n }, 1, xs)
}

min = |a, b| -> {
  if a < b then a else b
}

max = |a, b| -> {
  if a > b then a else b
}

minimum = |xs| -> {
  fold1 (min, xs)
}

maximum = |xs| -> {
  fold1 (max, xs)
}

even = (==) (0) `compose flip ((%)) (2)

odd = not `compose even
