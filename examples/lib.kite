-- dummy
length = |xs| -> {
  (xs # 1) + 1
}

slice  = |xs, from, to| -> {
  [xs # (1 + from + to)]
}

print = |str| -> { str }

-- utils
id = |x| -> { x }

not = |p| -> {
  if p then False else True
}

even = |x| -> { x % 2 == 0 }

odd = |x| -> { not (even (x)) }

-- list functions
empty = |xs| -> {
    length (xs) == 0
}

head = |xs| -> {
    xs # 0
}

tail = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 1, length (xs))
}

last = |xs| -> {
  if length (xs) == 1
    then last (tail (xs))
    else head (xs)
}

init = |xs| -> {
  if empty (xs)
    then []
    else slice (xs, 0, length (xs) - 1)
}

map = |f, xs| -> {
  if empty (xs)
    then []
    else [f (head (xs))] ++ map (f, tail (xs))
}

fold = |f, acc, xs| -> {
  if empty (xs)
    then acc
    else fold (f, f (acc, head (xs)), tail (xs))
}

fold1 = |f, xs| -> {
  if empty (xs)
    then head (xs) -- TODO: needs an error function
    else fold (f, head (xs), tail (xs))
}

filter = |f, xs| -> {
  if empty (xs)
    then []
    else if f (head (xs))
           then [head (xs)] ++ filter (f, tail (xs))
           else filter (f, tail (xs))
}

take = |n, xs| -> {
  if n <= 0 || empty (xs)
    then []
    else [head (xs)] ++ take (n - 1, tail (xs))
}

drop = |n, xs| -> {
  if n <= 0 || empty (xs)
    then xs
    else drop (n - 1, tail (xs))
}

all = |p, xs| -> {
  fold (|acc, x| -> { acc && p (x) }, True, xs)
}

any = |p, xs| -> {
  fold (|acc, x| -> { acc || p (x) }, False, xs)
}

flatten = |xs| -> {
  fold1 (|ls, x| -> { ls ++ x }, xs)
}

contains = |el, xs| -> {
  any (|x| -> { x == el}, xs)
}

rangeStep = |from, to, step| -> {
  inner = |from, to, ls| -> {
    if from > to
      then ls
      else [from] ++ inner (from + step, to, ls)
  }
  inner(from, to, [])
}

range = |from, to| -> {
  rangeStep (from, to, 1)
}

reverse = |xs| -> {
  if empty (xs)
    then []
    else reverse (tail (xs)) ++ [head (xs)]
}

-- quicksort
sort = |xs| -> {
  if empty (xs)
    then []
    else sort (filter (|x| -> { x < head (xs) }, tail (xs)))
         ++ [head (xs)]
         ++ sort (filter (|x| -> { x >= head (xs) }, tail (xs)))
}

-- numeric
sum = |xs| -> {
  fold (|acc, n| -> { acc + n }, 0, xs)
}

product = |xs| -> {
  fold (|acc, n| -> { acc * n }, 1, xs)
}

min = |a, b| -> {
  if a < b then a else b
}

max = |a, b| -> {
  if a > b then a else b
}

minimum = |xs| -> {
  fold1 (min, xs)
}

maximum = |xs| -> {
  fold1 (max, xs)
}

-- some testing
isPrime = |n, ps| -> {
  if n == 2
    then True
    else not (any (|x| -> { (n % x) == 0 }, ps))
}

primes = |lim| -> {
  fold (|ps, n| -> { if isPrime (n, ps) then [n] ++ ps else ps }, [2], rangeStep(3, lim, 2))
}

main = |a| -> {
  print (sort ([4, 5, 3, 7, 5, 0]))
  print (flatten ([[1, 2], [3, 4]]))
  print (length (primes (250)))
  print (reverse ([1, 2, 3, 4]))
}
