{
-- primitives
yes  = True
one  = 1
half = 0.5
str  = "foo"
lst  = [1, 2, 3, 4, 5]

-- binops
s = "str" + "ing"
l = [1, 2] + 3

-- simple func
foo = (a: Int) -> Int {
    return a + one
}

foo (2)

-- parameterless func
nopar = () -> Int {
    return 2
}

nopar ()

-- recursion
fib = (n: Int) -> Int {
    return
       if n == 0 then 0
       else if n == 1 then 1
       else fib (n - 1) + fib (n - 2)
}

fib (5)

-- nested recursion
fib = (n: Int) -> Int {
    foo = (p: Int) -> Int {
        return if p > 0
           then foo (2)
           else fib (2)
    }

    return foo (n - 1)
}

-- immediate evaluation

three = (n: Int) -> Int {
    return n + 1
}(2)

-- indexing
bar = (a: [Int]) -> Int {
    return (a # 0) + one
}

bar ([foo (one)])

-- hof
baz = (a: (Int) -> Int, b: String) -> String {
    if a (5) == 0 then {
       c = b + "bar"
    } else {
       foo (2)
    }
    return "hallo"
}

baz (foo, "foo")

-- inlined function
baz ((a: Int) -> Int { return a + 2 },
    "bar")

main = (args: [String]) -> Int {
     if (args # 0) == "foo"
        then { foo (2) }
        else { bar ([1, 2, 3]) }

     return 0
}

}