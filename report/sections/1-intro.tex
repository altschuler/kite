%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
TODO: 1-2 pages
\subsection{Programming languages and compilers in general}
TODO: Give a short description of a compiler.


Programming languages are the means for programmers to express what the machine should compute, or in other words: What a program should do.
The two main divisions between programming languages are likely whether they are High- or Low-level and which `programming paradigm' they follow (in the next section these paradigms will be shortly described).

The low-level languages are close to what the computer `natively` understand, which is machine code/instructions, but are harder for humans to read and write. Examples hereof are FOTRAN and COBOL. Usually high-level languages are used for faster development, better readability and maintenance, among other things. Thus it is of general interest... SOMETHING SOMETHING


TODO: Describe paradigms in the next subsection

A programming language is implemented via a compiler

\subsection{Programming paradigms}
Through the history of computer science, many different approaches to the design and implementation of programming languages have been taken. Most languages can be categorized as being either in the imperative or declarative style. Code written in imperative style is more explicit in \emph{how} a problem is solved, where declarative languages tend to describe \emph{what} is to be computed. There exists multiple language paradigms that fall under one or both of these categories.

A very popular paradigm is \textbf{object-oriented} programming (including \code{C++} and \code{Java}), in which data and algorithms are structured into objects that contain methods that can change the state of data in objects.

Another imperative approach is \textbf{procedural} languages like \code{C}, which is somewhat simpler and is characterized by subroutines, scoped variables and some sort of modules.

A very different style is the highly declarative \textbf{logic} programming, in which execution order and control-flow does not exist, but programs consist of logic clauses that define relationships and implications.

Kite is in the \textbf{functional} paradigm which, obviously, is characterized by a heavy use of functions and their composition. Functional languages are closely related to lambda calculus, and can sometimes even be seen as an extension of it. Common for them is that almost everything is regarded as an expression, meaning that everything conveys a \emph{value}. For instance, in imperative languages the \code{if} construct is a statement, controlling flow of execution, whereas in a functional language, it's a choice between two values. 

Another important feature common to functional languages is the concept of higher-order functions. A higher-order function is a function that either produces a function or takes a function as an argument. This is related to the idea of functions as so-called ``first-class citizen'', which basically means that a function can be passed around and transformed just like any other value type.

A very powerful concept regarding functions in general is that of partial application and currying. With partial application it is possible to apply a single argument to a function with multiple arguments, which produces a new function that accepts the remaining arguments. For instance, given the function $add(a, b) = a + b$, we can create a new function $increment = add(1)$ which will take \emph{one} argument and add $1$ to it. Currying is closely related, but is concerned with transforming a function of type $f : a \times b \rightarrow c$ to the function $f' : a \rightarrow b \rightarrow c$, thus enabling partial application.

When working in imperative language, mutation of variables is a core feature that is used in almost all parts of all programs. In a functional language however, it's common that variables are not in fact variable but rather declarations of values. For instance, to calculate the sum of a list of numbers (pseudo-code)

\begin{pseudo}
// imperative style
function sum(nums) do
  var s = 0
  foreach num in nums do
    s = s + num
  end
  return s
end

// functional style
function sum(nums) do
  return if length of nums is 0
    then 0
    else head(nums) + sum(tail(nums))
end
\end{pseudo}

Here we can see how the imperative code continuously mutates the \code{s} variable, and the functional code instead leverages recursion (and also is an example of the previously mentioned \code{if} as an expression).

The idea of immutability is related to the strive for controlling side effects. In a pure functional language any function will \emph{always} produce the same value, given the same input. This makes the code much easier to reason about, and can help the compiler make better optimizations.

\subsection{The problem}
In short, we want to make our own functional programming language, Kite, by implementing a compiler.


Kite will feature the basic elements of most functional languages (described above), and a few additional features:

\begin{itemize}

\item Static typing and thus typechecking
\item Closures
\item If-expressions (not to be confused with if-statements)

\end{itemize}

\subsection{The structure of the report}
TODO
