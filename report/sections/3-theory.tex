Kite is in the \textbf{functional} paradigm which, obviously, is characterized by a heavy use of functions and their composition. Functional languages are closely related to lambda calculus, and can sometimes even be seen as an extension of it. Common for them is that almost everything is regarded as an expression, meaning that everything conveys a \emph{value}. For instance, in imperative languages the \code{if} construct is a statement, controlling flow of execution, whereas in a functional language, it's a choice between two values. 

Another important feature common to functional languages is the concept of higher-order functions. A higher-order function is a function that either produces a function or takes a function as an argument. This is related to the idea of functions as so-called ``first-class citizen'', which basically means that a function can be passed around and transformed just like any other value type.

A very powerful concept regarding functions in general is that of partial application and currying. With partial application it is possible to apply a single argument to a function with multiple arguments, which produces a new function that accepts the remaining arguments. For instance, given the function $add(a, b) = a + b$, we can create a new function $increment = add(1)$ which will take \emph{one} argument and add $1$ to it. Currying is closely related, but is concerned with transforming a function of type $f : a \times b \rightarrow c$ to the function $f' : a \rightarrow b \rightarrow c$, thus enabling partial application.

When working in imperative language, mutation of variables is a core feature that is used in almost all parts of all programs. In a functional language however, it's common that variables are not in fact variable but rather declarations of values. For instance, to calculate the sum of a list of numbers (pseudo-code)

\begin{pseudo}
// imperative style
function sum(nums) do
  var s = 0
  foreach num in nums do
    s = s + num
  end
  return s
end

// functional style
function sum(nums) do
  return if length of nums is 0
    then 0
    else head(nums) + sum(tail(nums))
end
\end{pseudo}

Here we can see how the imperative code continuously mutates the \code{s} variable, and the functional code instead leverages recursion (and also is an example of the previously mentioned \code{if} as an expression).

The idea of immutability is related to the strive for controlling side effects. In a pure functional language any function will \emph{always} produce the same value, given the same input. This makes the code much easier to reason about, and can help the compiler make better optimizations.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
