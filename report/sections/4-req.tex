TODO: SKAL DER MERE?? FLERE EKSEMPLER ELLER ANDET GODT?

In the requirements we will focus more on the language specific features of
Kite. As most of the compiler specific requirements are discussed in
the design section, and are basic for most compilers, they will not
be discussed here. 

\subsection{Minimum requirements}
As of our initial requirements for Kite, we've set a list of minimum
requirements for our compiler.

\textbf{Type system:} Standard types that should be included in Kite is as
follows:
\begin{itemize}
\item [--] Float
\item [--] Integers
\item [--] Characters
\item [--] Boolean
\item [--] Lists
\item [--] Pairs
\end{itemize}
TODO Maaske mere? 

\textbf{Static type check:} In our initial analysis we wanted to
implement a static type checker. A static type checker will ensure
type safety in a given program. A program passing the static type
check will be free of type errors. If a program is verified from the
analyzer, the compiler will be able to trust the intermediate
representation given from the type checker. This will also result in
any type error will be caught compile-time.

\textbf{Code generation:} For the machine to be able to understand the
high-level language, a step of code generation is needed. Kites code
generator must be able to take some representation of the given source
code, and convert it such that the machine will be able to execute the
source code.

\textbf{Recursion:} As recursion is one of the main properties of
functional languages, recursion will be implemented in Kite. Recursion
is a function which calls itself to compute some corresponding $n$-th
element, while upholding some boundaries. One of the most used example
is the Fibonacci sequence, which can be defined in pseude-code as
follows:
\begin{pseudo}
// Fibo
function fibonacci(n) do
  return if n is 0
    then 0
  return else if n is 1
    then 1
  else fibonacci(n - 1) + fibonacci(n - 2)
\end{pseudo}

\subsection{Optional features}

\textbf{Standard library:} Inspired by Haskells prelude, we want to
implement a standard module imported by default into all Kite
modules. The standard module should include useful functions for
arithmetic operations, string manipulations and list manipulation.

\textbf{REPL:} A Read-eval-print-loop will allow the user to have an
interactive Kite shell. TODO: Mere guf omkring REPL?

\textbf{High order functions:} The language should have the
possibility to take functions as parameters and return functions.

\textbf{Mutability:} In a pure functional language there will be
immutability. As this is not perfect usefulness, we want at least some
mutability.

\textbf{Currying:} As we want all functions only to take one
parameter, we want to include currying. TODO: Mention lambda calculus
somewhere, Hindley Milner...

\textbf{Partial application:} As a result of currying, we want to make
use of partial application.

\textbf{Closures:} TODO

\textbf{Lazy evaluation:} The language should include lazy evaluation,
which will allow evaluation of expressions to be delayed until it's needed.

\textbf{Type inference:} This is an extension of the type
checker. Type inference will let the analyzer automatically deduct
types of expressions. 

\textbf{I/O:} Input/Output is needed for user interaction between the
user and computer. To make the language more usable, a minimum of I/O
must be present.

\textbf{Syntactic sugar:} To make some expressions more readable, we want to
implement a sugaring module.

\textbf{List comprehensions:} As list comprehensions is syntactic
sugar for creating new lists from already existing lists, this is an
extension of sugaring. List comprehensions will output new lists, as a
result of some operation performed on each element of another list (or
lists). It should also be possible to create a subsequence of the
elements of another list, by implying that each element in the created
list should satisfy a number of conditions.

\textbf{Preprocessing:} To make it possible to include another file
into a given program we want to make use of a preprocessor. The
preprocessor should be C-like where '\#include' is used. The
preprocessor should just be able to import external files into the
current program.


% Mutability
% REPL
% StdLib
% HoF
% Rekursion
% String interpolation
% Closures
% Lazy eval
% Parallel
% Currying
% Type system (static, strong)
% *Type inference
% I/O
% “alt = expressions”
% List comprehension
% (else?)

% Language features:
% Conditionals
% Functions
% “let … in”
% Loops (boobs)

% Typez:
% String
% List
% Int
% Float/double
% Tuples/structs

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
