TODO: Implementation of all 9 compiler-parts

\subsection{Preprocessor}
\subsection{Lexer}
The lexer is implemented with the lexical generator Alex \cite{dornan01}.

\subsection{Parser}
The parser is implemented with the LALR-parser generator Happy \cite{marlow01}. Happy automatically generates Haskell code from the file `src/Kite/Parser.y', which we have written in partially Haskell and partially Backus-Naur Form\footnote{This is a well known notation technique for specifying context-free grammars, which the more popular parser generator ANTLR also makes use of.}.

The current parser generates more than 2,000 lines of quite unreadable Haskell code, which is used in the compilation of the compiler. Fortunately Happy allows setting a --info flag when it is used, which also generates a .info-file about the parser. For instance it yields very useful information about shift-reduce and reduce-reduce conflicts, which has been a great throughout the development.

TODO (synes dette er lidt whack formuleret): `When a(/or a combination of) tokens are matched in the Parser, it is transformed into Haskell data-structures, from which we build the parse tree. TODO: Dette skal lede videre til syntactic zugar!


\subsection{Desugar}
\subsection{Analyser}

\subsubsection{Type inference}

TODO: define +plus `+'

As mentioned earlier, Kite uses static type checking to verify that types align at compile-time. We have used the Hindley-Milner type inference algorithm first described by Damas and Milner \cite{milner82}. They described an algorithm, named ``Algorithm W'', that given an expression will infer the most general type of that expression. We introduce the $\vdash$ to mean a derivation of type from expressions. For instance $x = 1 \vdash x : Int$ is read as ``given the expression $x = 1$ we can derive that $x$ has type $Int$''. To give a sense of what the algorithm does we first present a few examples. Recall that $:$ is pronounced ``has type''

Let the following be predefined
\begin{align*}
  +      & : a \to a \to a   \quad\text{(infix)}\\
  head   & : [a] \to a   \\
  fst    & : (a, b) \to a
\end{align*}

The algorithm can now infer the types of the following expressions
\begin{align*}
  \fn{xs}{head(xs) + 1} & \qcol [Int] \to Int    & \qvd xs : [Int]             \\
  \fn{p}{fst(p) + 1}    & \qcol (Int, a) \to Int & \qvd p : (Int, a)           \\
  f(n + 1)              & \qcol a                & \qvd f: (Int \to a), n: Int \\
\end{align*}

Using the last example above the intuition behind the algorithm is as follows

\begin{enumerate}
\item $e = \fn{f, n}{\ldots} \vdash e: (a \to b \to c)$ \\
  $e$ is being assigned a lambda expression with two parameters but we do not know anything about their types
\item $e = \fn{f, n}{f(\ldots)} \vdash f: d \to c$ \\
  $f$ is being applied to a single (yet unknown) value, thus we can infer that it is a function
\item $e = \fn{f, n}{f(n + 1)} \vdash n : Int$ \\
  We see that $f$ is applied to $n+1$ and since $1: Int$ and $+:a \to a \to a$ then $a = Int$ and thus $n:Int$ (this is called type unification, explained below).
\item $e = \fn{f, n}{f(n + 1)} \vdash e : (Int \to c) \to Int \to c$ \\
  There are no more expressions to infer so we end up with the final, most general type for $e$
\end{enumerate}


\paragraph{Type unification}\ \\
% TODO: ref to the section defining infix operators
Above we implicitly used the common definition of the $+$ operator with type $a \to a \to a$. When the type of $n$ was inferred, we \emph{unified} $Int$ with $a$ since $1 : Int$ and we knew from the type of $+$ that $n$ had the same type. This is called type unification and is at the core of the algorithm.

Formally the unification algorithm takes two types and either fails or returns a \emph{substitution} that maps the most general type to the most specific of the two.


cases
no subtyping

%TODO: lexer ~ regex ~ lexeme
%TODO: lexical scoping
%TODO: optimization inlining


\subsection{Optimizer}
\subsection{Code generation}

TODO: (i language-deisgn) Write reserved names (Void, if, then, else, etc...)

\subsection{Language constructs}

Kite consist of several different language constructs

List
Pair
Match
Bind
Lambda
Apply
If
Term
Group


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
