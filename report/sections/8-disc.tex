%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:


TODO:

Discuss the problems, challenges and solutions encountered. What did you learn? What gave you troubles? Interesting future extensions and improvements of the system can be discussed here as well.


TODO

\subsection{Challenges and solutions}
JavaScript as a means of emitting code, as LLVM proved very troublesome.

LLVM could likely be achieved by...
\begin{enumerate}
  \item updating the parse tree by annotating types
  \item finding out which types are used when calling generic(?) functions. As LLVM is strongly typed, and only support `single type' functions, we would have to note this in the compiler.
\end{enumerate}



\subsection{Known limitations}
\subsubsection{Data constructors and pattern matching}
A very powerful concept of languages like Haskell is Algebraic Data Types (ADT). ADTs provide the means for creating new data types that are composites of other types. They eliminate the need to ``hardcode'' types like \code{Bool} and \code{List}, because they can be defined in the language itself as an ADT. The \code{Bool} type is defined in Haskell as

\begin{haskell}
data Bool = True | False
\end{haskell}

This defines the \emph{data type} \code{Bool} with two \emph{type constructors} namely \code{True} and \code{False}.

ADTs can also take type parameters, which is used in the fundamental \code{List} type. Syntactic sugar allows a more succinct way to work with lists, but is treated as the following definition

\begin{haskell}
data List a = Nil | Cons a (List a)
\end{haskell}

This defines \code{List} as either \code{Nil} (commonly known as the empty list) or a \code{Cons} of an element of type \code{a} and another \code{List} also of type \code{a}. This definition of the list type is a great example of the power of ADTs. \code{Cons} can be thought of as prepending an element to another list.

Because Kite has no notion of ADTs and lists are implemented as arrays of values like other imperative language, pattern matching is difficult because we cannot destruct a list to its elements in a tree structure. With ADTs it is simpler because data structures are inherently trees and can be traversed to match a pattern to an expression and provide bindings from the pattern variables corresponding to the matched expression.

A pattern is a tree with variable names as leafs. The non-variable parts of the pattern must agree with the expression tree in terms of the labelling of nodes, the number of children and the ordering of the subtrees\cite[p. 514]{wilhelm95} for a match to be successful. This can be visualized as in figure~\ref{fig:pattern-match}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \begin{tikzpicture}
      \tikzstyle{every node}=[]
      \node {\code{:}}
      child { node {\code{T1}} }
      child {
        node {\code{:}}
        child { node {\code{T2}} }
        child { node {\code{T3}} }
      };
    \end{tikzpicture}
    \caption{A pattern}
  \end{subfigure}
  \begin{subfigure}[t]{0.32\textwidth}
    \centering
    \begin{tikzpicture}
      \tikzstyle{every node}=[]
      \node {\code{:}}
      child { node {\code{1}} }
      child {
        node {\code{:}}
        child { node {\code{2}} }
        child {
          node {\code{:}}
          child { node {\code{3}} }
          child { node {\code{Nil}} }
        }
      };
    \end{tikzpicture}
    \caption{An expression to be matched}
  \end{subfigure}
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \begin{tikzpicture}
      \node (T1) {\code{T1}} [grow'=right, ->]
      child { node {\code{1}} };

      \node [below=0.5cm of T1]  (T2) { \code{T2} } [grow'=right, ->]
      child { node {\code{2}} };

      \node [below=0.5cm of T2] (T3) {\code{T3}} [grow'=right, ->]
      child {
        node {\code{:}} [grow'=down]
        child { node {\code{Nil}} }
        child { node {\code{3}} }
      };
    \end{tikzpicture}
    \caption{The resulting bindings}
    \label{subfig:pat-binding}
  \end{subfigure}
  \caption{Pattern (a) is matched with expression (b) resulting in the bindings (c)}
  \label{fig:pattern-match}
\end{figure}

It can be seen how the variables in the pattern are bound to the corresponding nodes in the matched expression resulting in the bindings in figure \ref{subfig:pat-binding}. Implementation-wise the pattern and expression will be simultaneously traversed and every time a variable is visited in the pattern the current node of the expression is bound to that identifier. One can also use literal values and thus restrict a successful match to expressions that contain the same literal values in the same leafs.

TODO: Limitation with Hindley-Milner (it does not allow subtypes... \#panic - groupleader)

TODO: Limitation with CFG, and since we use Happy, we cannot do: TODO - example.. NVM maybe? Because what cannot be done with a CFG can probably just be added later on.

TODO: In Kite the order of declarations matter, optimally they should not.

TODO: Hvordan ville vi klare subtypes? Fx at int og floats begge er numeralz

TODO: Pattern matching! We could have made this properly by doing as written in the book Probst handed us (matching in the shape of the AST)


\subsection{Further development}

TODO: Data structures.

TODO: I/O?
\subsubsection{Optimizations}
\label{sec:disc-optimization}

\paragraph{Tail call}
As seen in our first benchmark \ref{sec:math-benchmark}, Kite is scaling badly with the function \code{map}, as the call stack grows linearly with the length of the lists. \code{map} uses a tail-recursive call, which allows for tail call elimination: As the application of the argument-function\footnote{By `argument-function' we refer to the function given as an argument to \code{map} along with a list} to each of the elements of the list is independent from the others, it is not strictly necessary to add a new stack frame to the call stack.

\paragraph{Uncurrying of functions} Despite currying is a very powerful concept, it is not very efficient when emitted. It creates more function calls than strictly necessary. A potential optimization could be to uncurry functions which are called, but never partially applied. This eliminates some unnecessary function calls, as functions in JavaScript takes multiple parameters. This will also hold for other target output languages where functions take multiple parameters, such as LLVM.
