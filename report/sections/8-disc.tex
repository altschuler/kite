%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:


\subsection{Known limitations}
\subsubsection{Data constructors and pattern matching}
A very powerful concept of languages like Haskell is Algebraic Data Types (ADT). ADTs provide the means for creating new data types that are composites of other types. They eliminate the need to ``hardcode'' types like \code{Bool} and \code{List}, because they can be defined in the language itself as an ADT. The \code{Bool} type is defined in Haskell as

\begin{haskell}
data Bool = True | False
\end{haskell}

This defines the \emph{data type} \code{Bool} with two \emph{type constructors} namely \code{True} and \code{False}.

ADTs can also take type parameters, which is used in the fundamental \code{List} type. Syntactic sugar allows a more succinct way to work with lists, but is treated as the following definition

\begin{haskell}
data List a = Nil | Cons a (List a)
\end{haskell}

This defines \code{List} as either \code{Nil} (commonly known as the empty list) or a \code{Cons} of an element of type \code{a} and another \code{List} also of type \code{a}. This definition of the list type is a great example of the power of ADTs. \code{Cons} can be thought of as prepending an element to another list.

Because Kite has no notion of ADTs and lists are implemented as arrays of values like other imperative language, pattern matching is difficult because we cannot destruct a list to its elements in a tree structure. With ADTs it is simpler because data structures are inherently trees and can be traversed to match a pattern to an expression and provide bindings from the pattern variables corresponding to the matched expression.

A pattern is a tree with variable names as leafs. The non-variable parts of the pattern must agree with the expression tree in terms of the labelling of nodes, the number of children and the ordering of the subtrees\cite[p. 514]{wilhelm95} for a match to be successful. This can be visualized as in figure~\ref{fig:pattern-match}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \begin{tikzpicture}
      \tikzstyle{every node}=[]
      \node {\code{:}}
      child { node {\code{T1}} }
      child {
        node {\code{:}}
        child { node {\code{T2}} }
        child { node {\code{T3}} }
      };
    \end{tikzpicture}
    \caption{A pattern}
  \end{subfigure}
  \begin{subfigure}[t]{0.32\textwidth}
    \centering
    \begin{tikzpicture}
      \tikzstyle{every node}=[]
      \node {\code{:}}
      child { node {\code{1}} }
      child {
        node {\code{:}}
        child { node {\code{2}} }
        child {
          node {\code{:}}
          child { node {\code{3}} }
          child { node {\code{Nil}} }
        }
      };
    \end{tikzpicture}
    \caption{An expression to be matched}
  \end{subfigure}
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \begin{tikzpicture}
      \node (T1) {\code{T1}} [grow'=right, ->]
      child { node {\code{1}} };

      \node [below=0.5cm of T1]  (T2) { \code{T2} } [grow'=right, ->]
      child { node {\code{2}} };

      \node [below=0.5cm of T2] (T3) {\code{T3}} [grow'=right, ->]
      child {
        node {\code{:}} [grow'=down]
        child { node {\code{Nil}} }
        child { node {\code{3}} }
      };
    \end{tikzpicture}
    \caption{The resulting bindings}
    \label{subfig:pat-binding}
  \end{subfigure}
  \caption{Pattern (a) is matched with expression (b) resulting in the bindings (c)}
  \label{fig:pattern-match}
\end{figure}

It can be seen how the variables in the pattern are bound to the corresponding nodes in the matched expression resulting in the bindings in figure \ref{subfig:pat-binding}. Implementation-wise the pattern and expression will be simultaneously traversed and every time a variable is visited in the pattern the current node of the expression is bound to that identifier. One can also use literal values and thus restrict a successful match to expressions that contain the same literal values in the same leafs.

TODO: Limitation with Hindley-Milner (it does not allow subtypes... \#panic - groupleader)

TODO: Limitation with CFG, and since we use Happy, we cannot do: TODO - example.. NVM maybe? Because what cannot be done with a CFG can probably just be added later on.

TODO: In Kite the order of declarations matter, optimally they should not.

TODO: Hvordan ville vi klare subtypes? Fx at int og floats begge er numeralz
