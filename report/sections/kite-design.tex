We have been inspired by many other languages when designing and
implementing Kite, most notably the GHC Haskell compiler\footnote{The
  Glasgow Haskell Compiler \url{http://www.haskell.org/ghc}}.

\subsection{Syntax}

TODO: Sugar, List Comprehensions, describe types, more on function declaration.

\textbf{Basic types and declarations}

Basic declaration of the variables in Kite, types are inferred by the analyzer:
\begin{kite}
  
  one = 1
  two = 2.0
  truth = True
  list = [1, 2, 3, 4]
  char = 'a' 
  pair = (1, 'a')
\end{kite}

The basic types will be Int, Float, Bool, Lists, Chars and
pairs.

Functional languages often make extensive use of lists, which is
indeed also the case for Kite. A list is an ordered array of items
that can be transformed in many different ways. We use a common
short-hand method for describing a list of things, using square
brackets $[\ ]$. For instance, a $List(Int)$ (pronounced ``List of
Ints'') is denoted $[Int]$ and a list of a type variables $a$ is
$[a]$. Lists can be nested, allowing $List(List(Int))$ denoted
$[[Int]]$.

The pair type is also abbreviated using $(,)$, for instance the type
$Pair(Int, Bool)$ is written $(Int, Bool)$

Strings is represented as syntactic sugar for lists of characters,
which will be discussed later.

Basic arithmetic operators in Kite and their us
\begin{kite}

  two = 1 + 1  ---->  2
  mod = 10 % 2 ---> 0
\end{kite}

\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation    & Meaning              \\ \hline
    x + y        & Additition           \\ \hline
    x - y        & Subtraction          \\ \hline
    x * y        & Multiplication       \\ \hline
    x / y        & Division             \\ \hline
    x**y         & Exponentiation       \\ \hline
    x \% m       & Remainder of x / y   \\ \hline
    pow(x, y, m) & Modulo exponentation \\ \hline
    \end{tabular}
\end{table}
Note: some operators will only work on certain types.

Basic boolean operators:
\begin{kite}
  
  foo = 1 < 2  ----> True
  bar = 1 == 2 ----> False
\end{kite}
Basic boolean operators include 
\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation & Meaning                 \\ \hline
    $==$        & Equal                   \\ \hline
    $\backslash=$        & Not equal               \\ \hline
    $<=$        & Less than or equal than \\ \hline
    $>=$        & Greater than or equal   \\ \hline
    $<$         & Less than               \\ \hline
    $>$         & Greater than            \\ \hline
    \end{tabular}
\end{table}

A single basic bitwise operator:
\begin{kite}
  
  xor = 10 ^ 8 ----> 2
\end{kite}
Kite only includes xor bitwise operator as of now.

\textbf{Conditionals}


TODO Conditional statements:
Kite includes basic if-then-else-statements:
\begin{kite}
  
  if BoolStatement then Statement else Statement
\end{kite}
A more advanced form of the if-then-else-statement is the pattern
matching, which will be discussed later.
Function declaration in Kite:

\textbf{Function declaration}

Every function in Kite is declared as an anonymous function:
\begin{kite}
  
|ArgName, ... | -> { ... }
\end{kite}

Since everything in Kite is an expression, functions is simply a
variable bound to a given anonymous function. A function is declared
as follows:
\begin{kite}
  
  function :: ArgType -> ... -> ReturnType
  function = |ArgName, ... | -> { ... }
\end{kite}
Example of valid function declaration in Kite, taking one parameter of
the type Int and returning an Int.
\begin{kite}
  
  foo :: Int -> Int
  foo = |a| -> {
    a + 1
  }
\end{kite}
A runnable program must always include the `main' function, which will be called once when the emitted code is run by Node.js:
\begin{kite}
  
  main = -> { ... }
\end{kite}

In order to use the preprocessor to include another code file, use the \texttt{\#include} keyword:
\begin{kite}
  
  #include "foo.kite"
\end{kite}

\textbf{Syntactic sugar}

By using a sugaring module, Kite will be able to express certain
functions more clearly and readable. Syntactic sugar includes infix
operators, multiple parameters on function calls, list of characters
as strings and list comprehensions.
Infix operators will allow infix use of certain functions in Kite. An
example of infix operators is the basic + arithmetic operation:
\begin{kite}
  
  foo = 1 + 2
\end{kite}

Where the desugared version of the same statement is given as:

\begin{kite}

  foo = ((+) (1)) (2)
\end{kite}

As Kite functions will only take one parameter, sugaring of multiple
parameter functions (or currying, see currying in \ref{sec:currying})
will allow the usage of multiple parameter functions. Example of usage
of multiple parameters:
\begin{kite}
  
  foo = |a, b| -> {
    a + b
  }
\end{kite}
Which will be a syntactic sugar for the following code:
\begin{kite}

  foo = |a| -> {
    return |b| -> {
      return ((+) (a)) (b)
    }
  }
\end{kite}

Strings are syntactic sugar for list of characters, $List(Char)$,
which will allow for easier representations of character lists. An
example of a string is as follows:
\begin{kite}
  
  str = "Hello"
\end{kite}

Where the corresponding desugar (note the distinction between strings
using double-quite (") and characters using single-quite (') will be:
\begin{kite}
  
  str = ['H', 'e', 'l', 'l', 'o']
\end{kite}

\label{sec:ex-listcomp}
List comprehensions are syntactic sugar for manipulating
lists. An example of a list comprehension is as follows:
\begin{kite}
  
  list = [ x*y | x <- range(3,5), y <- range(4,6) | (x+y) >= 10, y > 4]
\end{kite}
where the desugared version of the given example, will look as follows:
\begin{kite}

  list =
  flatMap(|x| -> {
    flatMap (|y| -> {
      if (|x,y| -> {y > 4})(x,y) && (|x,y| -> {(x+y) >= 10})(x,y) 
         then [(|x,y| -> {x*y})(x,y)] 
         else []
    } , range(4,6) )
}, range(3,5) )
\end{kite}
Take note that list comprehensions uses functions defined in the
foundation, which will be discussed later
\subsection{Semantics}
\label{sec:currying}

TODO: Recursion, HoF, Currying, pattern matching,
partial application, Mutability, conditionals maaske mere.

\textbf{Pattern matching}


Both pattern matching and recursion is used in the example below:
\begin{kite}

fibo = |a, b, n| -> {
    match n {
    0 -> a,
    n -> fibo(b, (a + b), (n - 1))
    }
}
\end{kite}

TODO Pattern matching can also be applied on lists and pairs.

\subsection{Foundation}

As earlier mentioned, the foundation of Kite is a standard library
consisting of often used functions. Kites foundation is inspired by
Haskells prelude, and includes many functions found in
prelude. 
TODO: MORE FUN FUN FUN

Foundation examples.
List concatenation:
\begin{kite}

  {++} :: [a] -> [a] -> [a]
  {++} = |l, r| -> {
    match l {
      [] -> r,
      x,xs -> x : (xs ++ r)
    }
  }
\end{kite}
Can be used to concatenate lists and strings.

List index:
\begin{kite}

  {#} :: [a] -> Int -> a
  {#} = |xs, idx| -> {
    match xs {
      [] -> panic ("list index too large"),
      x,xs -> if idx == 0 then x else xs # (idx - 1)
    }
  }
\end{kite}

For documentation of rest of Foundation, see \nameref{foundation}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
