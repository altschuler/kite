We have been inspired by many other languages when designing and
implementing Kite, most notably the GHC Haskell compiler\footnote{The
  Glasgow Haskell Compiler \url{http://www.haskell.org/ghc}}.

\subsection{Syntax and semantics}
In this section we will describe how to use the different features of Kite and how they work, i.e. the syntax and semantics.

TODO: Sugar, List Comprehensions, describe types, more on function declaration.

TODO: Parameterless functions, implicit return, blocks

\subsubsection{Basic types and declarations}

Basic declaration of the variables in Kite, types are inferred by the analyzer:
\begin{kite}
  
  one = 1
  two = 2.0
  truth = True
  list = [1, 2, 3, 4]
  char = 'a' 
  pair = (1, 'a')
\end{kite}

The basic types will be Int, Float, Bool, Lists, Chars and
pairs.

Functional languages often make extensive use of lists, which is
indeed also the case for Kite. A list is an ordered array of items
that can be transformed in many different ways. We use a common
short-hand method for describing a list of things, using square
brackets $[\ ]$. For instance, a $List(Int)$ (pronounced ``List of
Ints'') is denoted $[Int]$ and a list of a type variables $a$ is
$[a]$. Lists can be nested, allowing $List(List(Int))$ denoted
$[[Int]]$.

The pair type is also abbreviated using $(,)$, for instance the type
$Pair(Int, Bool)$ is written $(Int, Bool)$

Strings is represented as syntactic sugar for lists of characters,
which will be discussed later.

Basic arithmetic operators in Kite and their us
\begin{kite}

  two = 1 + 1  ---->  2
  mod = 10 % 2 ---> 0
\end{kite}

\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation    & Meaning              \\ \hline
    x + y        & Additition           \\ \hline
    x - y        & Subtraction          \\ \hline
    x * y        & Multiplication       \\ \hline
    x / y        & Division             \\ \hline
    x**y         & Exponentiation       \\ \hline
    x \% m       & Remainder of x / y   \\ \hline
    pow(x, y, m) & Modulo exponentation \\ \hline
    \end{tabular}
\end{table}
Note: some operators will only work on certain types.

Basic boolean operators:
\begin{kite}
  
  foo = 1 < 2  ----> True
  bar = 1 == 2 ----> False
\end{kite}
Basic boolean operators include 
\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation & Meaning                 \\ \hline
    $==$        & Equal                   \\ \hline
    $\backslash=$        & Not equal               \\ \hline
    $<=$        & Less than or equal than \\ \hline
    $>=$        & Greater than or equal   \\ \hline
    $<$         & Less than               \\ \hline
    $>$         & Greater than            \\ \hline
    \end{tabular}
\end{table}

A single basic bitwise operator:
\begin{kite}
  
  xor = 10 ^ 8 ----> 2
\end{kite}
Kite only includes xor bitwise operator as of now.

\subsubsection{Function declaration}

Every function in Kite is declared as an anonymous function:
\begin{kite}
  
|ArgName, ... | -> { ... }
\end{kite}

Since everything in Kite is an expression, functions is simply a
variable bound to a given anonymous function. A function is declared
as follows:
\begin{kite}
  
  function :: ArgType -> ... -> ReturnType
  function = |ArgName, ... | -> { ... }
\end{kite}
Example of valid function declaration in Kite, taking one parameter of
the type Int and returning an Int.
\begin{kite}
  
  foo :: Int -> Int
  foo = |a| -> {
    a + 1
  }
\end{kite}
A runnable program must always include the `main' function, which will be called once when the emitted code is run by Node.js:
\begin{kite}
  
  main = -> { ... }
\end{kite}

In order to use the preprocessor to include another code file, use the \texttt{\#include} keyword:
\begin{kite}
  
  #include "foo.kite"
\end{kite}

\subsubsection{Syntactic sugar}

By using a sugaring module, Kite will be able to express certain
functions more clearly and readable. Syntactic sugar includes infix
operators, multiple parameters on function calls, list of characters
as strings and list comprehensions.
Infix operators will allow infix use of certain functions in Kite. An
example of infix operators is the basic + arithmetic operation:
\begin{kite}
  
  foo = 1 + 2
\end{kite}

Where the desugared version of the same expression is given as:

\begin{kite}

  foo = ((+) (1)) (2)
\end{kite}

As Kite functions will only take one parameter, sugaring of multiple
parameter functions (or currying, see currying in \ref{subsubsec:currying})
will allow the usage of multiple parameter functions. Example of usage
of multiple parameters:
\begin{kite}
  
  foo = |a, b| -> {
    a + b
  }
\end{kite}

Which will be syntactic sugar for the following code:
\begin{kite}

  foo = |a| -> {
    return |b| -> {
      return ((+) (a)) (b)
    }
  }
\end{kite}

\textbf{Parameterless functions} are also syntactic sugar. For instance the main function is often declared as follows:

\begin{kite}

main = -> 
{
  ...
}
\end{kite}

and this is simply shorthand for

\begin{kite}

main = |Void| -> 
{
  ...
}
\end{kite}

\textbf{Strings} are syntactic sugar for list of characters, $List(Char)$,
which will allow for easier representations of character lists. An
example of a string is as follows:
\begin{kite}
  
  str = "Hello"
\end{kite}

Where the corresponding desugar (note the distinction between strings
using double-quite (") and characters using single-quite (') will be:
\begin{kite}
  
  str = ['H', 'e', 'l', 'l', 'o']
\end{kite}


\label{sec:ex-listcomp}
\textbf{List comprehensions} are syntactic sugar for manipulating
lists. An example of a list comprehension is as follows:
\begin{kite}
  
  list = [ x*y | x <- range(3,5), y <- range(4,6) | (x+y) >= 10, y > 4]
\end{kite}
where the desugared version of the given example, will look as follows:
\begin{kite}

  list =
  flatMap(|x| -> {
    flatMap (|y| -> {
      if (|x,y| -> {y > 4})(x,y) && (|x,y| -> {(x+y) >= 10})(x,y) 
         then [(|x,y| -> {x*y})(x,y)] 
         else []
    } , range(4,6) )
}, range(3,5) )
\end{kite}
Take note that list comprehensions uses functions defined in the
foundation, which will be discussed later

\subsubsection{Recursion}

We have implemented recursion, and examples hereof are in the following where we also show pattern matching.


\subsubsection{Conditionals}

Kite features two conditional expressions, the if-expression and pattern matching.



The \textbf{if-expression} is not to be confused with an if-statement, as our implementation is not a control flow statement. It will always return an expression, and the return-types of the consequence and alternative must be the same.


\begin{kite}
  
  if BoolExpression then Expression else Expression
\end{kite}


A more advanced form of conditional is \textbf{pattern matching}. Some pattern matching is possible in Kite. As we haven't implemented type declaration (TODO - sry, Groupleader) ...

... we have hardcoded the most basic cases of pattern matching. This includes matching pairs, expressions, lists and `otherwise'.


Below we show the matching of `n' on 0, which is an expression, and `otherwise', which is written `\_':
\begin{kite}

fibo = |a, b, n| -> {
    match n {
    0 -> a,
    _ -> fibo(b, (a + b), (n - 1))
    }
}
\end{kite}

An example of pattern matching on lists is our implementation of the function `reverse' \ref{foundation} (TODO ref to Foundation), which matches `xs' with an expression, the empty list, and the head and tail of `xs':

\begin{kite}

reverse = |xs| -> {
  match xs {
    []    -> [],
    x,xs  -> reverse (xs) ++ [x]
  }
}

\end{kite}

TODO - skriv at vi ikke kan matche nestede ting

The final case is matching on pairs. The example below shows our implementation of the function `fst' (first):
\begin{kite}

fst :: (a, b) -> a
fst = |p| -> {
  match p {
    (a , b) -> a
  }
}
\end{kite}

\subsubsection{High order functions (HoF)}
Kite features HoF, and the map-function is an example hereof. It takes a function and applies to every element of a list and returns the modified list:

\begin{kite}

map :: (a -> b) -> [a] -> [b]
map = |f, ls| -> {
  match ls {
    [] -> [],
    x,xs -> f (x) : map (f, xs)
  }
}
\end{kite}

\subsubsection{Currying}
\label{subsubsec:currying}
TODO: Currying

\subsubsection{Partial application}

An example of partial application is the function `increment', which partially applies addition:

\begin{kite}

increment :: Int -> Int
increment = (1+)

\end{kite}

\subsection{Foundation}

As earlier mentioned, the foundation of Kite is a standard library
consisting of often used functions. Kites foundation is inspired by
Haskells prelude, and includes many functions found in
prelude. 
TODO: MORE FUN FUN FUN

Foundation examples.
List concatenation:
\begin{kite}

  {++} :: [a] -> [a] -> [a]
  {++} = |l, r| -> {
    match l {
      [] -> r,
      x,xs -> x : (xs ++ r)
    }
  }
\end{kite}
Can be used to concatenate lists and strings.

List index:
\begin{kite}

  {#} :: [a] -> Int -> a
  {#} = |xs, idx| -> {
    match xs {
      [] -> panic ("list index too large"),
      x,xs -> if idx == 0 then x else xs # (idx - 1)
    }
  }
\end{kite}

For documentation of rest of Foundation, see \nameref{foundation}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
