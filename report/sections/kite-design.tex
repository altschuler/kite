We have been inspired by many other languages when designing and implementing Kite, most notably the GHC Haskell Compiler~\footnote{The Glasgow Haskell Compiler \url{http://www.haskell.org/ghc}}.


\subsection{Syntax and semantics}
In this section we will describe how to use the different features of Kite and how they work, i.e. the syntax and semantics.

\subsubsection{Basic types and declarations}
Basic declaration of the variables in Kite, types are inferred by the analyzer:

\begin{kite}
one = 1
two = 2.0
truth = True
list = [1, 2, 3, 4]
char = 'a'
pair = (1, 'a')
\end{kite}

The basic types will be Int, Float, Bool, Lists, Chars and pairs.

Functional languages often make extensive use of lists, which is
indeed also the case for Kite. A list is an ordered array of items
that can be transformed in many different ways. We use a common
short-hand method for describing a list of things, using square
brackets \code{[\ ]}. For instance, a \code{List(Int)} (pronounced ``List of
Ints'') is denoted \code{[Int]} and a list of a type variables $a$ is
\code{[a]}. Lists can be nested, allowing \code{List(List(Int))} denoted \code{[[Int]]}.

The pair type is also abbreviated using $(\ ,\ )$, for instance the type \code{Pair(Int, Bool)} is written \code{(Int, Bool)}

Strings are represented as syntactic sugar for lists of characters. For
instance, \code{['f', 'o', 'o']} has the sugared version \code{"foo"}. This will be discussed later.

Basic arithmetic operators:
\begin{kite}
two = 1 + 1  ---->  2
rest = 10 % 2 ---> 0
\end{kite}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Operation      & Meaning              \\ \hline
    $\code{x + y}$        & Additition           \\ \hline
    $\code{x - y}$        & Subtraction          \\ \hline
    $\code{x * y}$        & Multiplication       \\ \hline
    $\code{x / y}$        & Division             \\ \hline
    $\code{x**y}$         & Exponentiation       \\ \hline
    $\code{x \% m}$       & Remainder of x / y   \\ \hline
    $\code{powmod(x, y, m)}$ & Modulo exponentation \\ \hline
  \end{tabular}
  \label{tbl:kite-design-arith-op}
  \caption{Basic arithmetic operators in Kite}
\end{table}
Note: some operators will only work on certain types.

Basic boolean operators:
\begin{kite}
foo = 1 < 2  ----> True
bar = 1 == 2 ----> False
\end{kite}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Operation     & Meaning                 \\ \hline
    $\code{==}$          & Equal                   \\ \hline
    $\code{/=}$ & Not equal               \\ \hline
    $\code{<=}$          & Less than or equal than \\ \hline
    $\code{>=}$          & Greater than or equal   \\ \hline
    $\code{<}$           & Less than               \\ \hline
    $\code{>}$           & Greater than            \\ \hline
  \end{tabular}
  \label{tbl:kite-disign-bool-op}
  \caption{Basic boolean operators in Kite}
\end{table}

A single basic bitwise operator:
\begin{kite}
10 ^ 8 ----> 2
\end{kite}
Kite only includes the XOR bitwise operator, as of now.


\subsubsection{Function declaration}
Every function in Kite is declared as an anonymous function:

\begin{kite}
|param_1, ..., param_n| -> {
  expr_1;
  ...
  expr_n
}
\end{kite}

A function (lambda expression) is defined as a list of arguments and a block. A block is defined as a list of expressions optionally separated by \code{;}, where it is implicit that the last expression is returned as the result of the functions. A block introduces a new lexical scope, capturing its parent scope.

There are no named functions in Kite, but lambda expressions can be bound to identifers. A function is declared as follows:

\begin{kite}
functionName :: ArgType -> ... -> ReturnType
functionName = |argOne, ...| -> { ... }
\end{kite}

Example of a valid function declaration in Kite, taking one parameter of the type \code{Int} and returning an \code{Int}:

\begin{kite}
foo :: Int -> Int
foo = |a| -> {
  a + 1
}
\end{kite}

A runnable program must always include the \code{main} function of type \code{Void -> a}, which will be used as the entry point for execution:

\begin{kite}
main = -> { ... }
\end{kite}

In order to use the preprocessor to include another code file, use the \code{\#include} keyword:
\begin{kite}
#include "foo.kite"
\end{kite}

\subsubsection{Syntactic sugar}
\label{sec:kite-design-sugar}
By using a sugaring module, Kite will be able to express certain functions more clearly and readable to the user. Syntactic sugar includes infix operators, multiple parameters on function calls, list of characters as strings and list comprehensions. Infix operators will allow infix use of binary functions (taking two parameters) in Kite. An example of infix operators is the basic $+$ arithmetic operation:

\begin{kite}
foo = 1 + 2
\end{kite}

Where the desugared version of the same expression is given as:

\begin{kite}
foo = ((+) (1)) (2)
\end{kite}

As Kite functions will only take one parameter, sugaring of multiple parameter functions (or currying, see currying~\ref{subsubsec:currying}) will allow the usage of multiple parameter functions. Example of usage of multiple parameters:

\begin{kite}
foo :: a -> a -> a
foo = |a, b| -> {
  a + b
}
\end{kite}

Which will be syntactic sugar for the following:

\begin{kite}
foo :: a -> a -> a
foo = |a| -> {
  return |b| -> {
    return ((+) (a)) (b)
  }
}
\end{kite}

\textbf{Parameterless functions} are also syntactic sugar. For instance the main function is often declared as follows:

\begin{kite}
main = -> {
  ...
}
\end{kite}

This is simply shorthand for

\begin{kite}
main = |Void| -> {
  ...
}
\end{kite}

As mentioned earlier, \textbf{Strings} are syntactic sugar for list of characters, \code{List(Char)}, which will allow for easier representations of character lists. An example of a strings:

\begin{kite}
str = "Hello"
\end{kite}

Where the corresponding desugar (note the distinction between strings using double-quotes ("...") and characters using single-quotes ('...') will be:

\begin{kite}
str = ['H', 'e', 'l', 'l', 'o']
\end{kite}

\label{sec:ex-listcomp}
\textbf{List comprehensions} are syntactic sugar for manipulating lists. An example of a list comprehension is:

\begin{kite}
list = [ x*y | x <- range(3,5), y <- range(4,6) | (x+y) >= 10, y > 4]
\end{kite}

Where the desugared version of the given example, will look as follows:

\begin{kite}
list =
flatMap(|x| -> {
  flatMap (|y| -> {
    if (|x,y| -> {y > 4})(x,y) && (|x,y| -> {(x+y) >= 10})(x,y)
       then [(|x,y| -> {x*y})(x,y)]
       else []
  } , range(4,6) )
}, range(3,5) )
\end{kite}

Note that list comprehensions uses functions defined in
\nameref{foundation}), which will be discussed later.

\textbf{Infix functions} Kite allows for use of infix functions. Infix
functions are syntactic sugar for prefix function calls, with some
given parameters. Using \code{`} (backtick) will imply the use of
infix function calls

A common example of infix function calls, is the \code{elem}
-function, which is defined as follows (from \nameref{foundation}):
\begin{kite}
  elem :: a -> [a] -> Bool
  elem = |el| -> {
    any ((el==))
  }
\end{kite}
The following Kite example will be an example of usage of
\code{elem}. \code{elem} is here used as an infix function call.
\begin{kite}
  foo =  -> {
    list = [1, 2, 3]
    1 `elem list
  }
\end{kite}
The resulting desugared version of same example will look as follows:

\begin{kite}
  foo = |Void| -> {
    list = [1,2,3];
    a = ((elem) (1)) (list);
    return a
  }
\end{kite}

\subsubsection{Recursion}
Kite supports recursion, which allows functions to call itself in
programs. Basic recursion will have the following syntax:
\begin{kite}
  foo :: Int -> Int
  foo = |a| -> {
    if a == 1 then 1
    else a + foo(a - 1)
  }
\end{kite}
Kite also supports recursion in pattern matching, which will be
discussed later in \nameref{subsubsec:conditionals}.

\subsubsection{Conditionals}
\label{subsubsec:conditionals}
Kite features two conditional expressions, the if-expression and pattern matching.

The \textbf{if-expression} is not to be confused with an if-statement, as our implementation is not a control flow statement. It will always return an expression, and the return-types of the consequent and alternative must be the same.

\begin{kite}
if booleanExpression then consequenceExpression else alternativeExpression
\end{kite}

A more advanced form of conditional is \textbf{pattern matching}. It works by matching an expression to a list of cases, which can be either a normal expression or it can be a destructuring of a list or a pair.

Below we show the matching of \code{n} on 0, which is an expression,
and \code{otherwise}, which is written \code{"\_"}:

\begin{kite}
fibo :: a -> b -> Int -> a
fibo = |a, b, n| -> {
    match n {
    0 -> a,
    _ -> fibo(b, (a + b), (n - 1))
    }
}
\end{kite}

An example of pattern matching on lists is our implementation of the function \code{reverse}~\ref{foundation}, which matches \code{xs} with an expression, empty list, and the head and tail of \code{xs}:

\begin{kite}
reverse = |xs| -> {
  match xs {
    []    -> [],
    x,xs  -> reverse (xs) ++ [x]
  }
}
\end{kite}

The final case is matching on pairs. The example below shows the implementation of \code{fst} (first) in \nameref{foundation}):
\begin{kite}
fst :: (a, b) -> a
fst = |p| -> {
  match p {
    (a , b) -> a
  }
}
\end{kite}

\subsubsection{Higher-order functions}
Kite features higher-order functions (HoF), and the \code{map} function is an example hereof. It takes a function as argument and applies it to every element of a list, and returns the modified list:

\begin{kite}
map :: (a -> b) -> [a] -> [b]
map = |f, ls| -> {
  match ls {
    [] -> [],
    x,xs -> f (x) : map (f, xs)
  }
}
\end{kite}

\subsubsection{Currying}
\label{subsubsec:currying}
Beside every function in Kite being curried~\footnote{Which should be fairly easy to see when looking at the type-declarations of the functions}, we have also implemented a \code{curry} (and \code{uncurry}) function, which given a function with a single pair as the argument, returns the same function taking two arguments corresponding to the values of the pair:

\begin{kite}
curry :: ((a, b) -> c) -> (a -> b -> c)
curry = |f| -> {
  |a,b| -> {
    f((a,b))
  }
}
\end{kite}

Uncurry, naturally, does the opposite, meaning it takes a function taking two parameters and returns the same taking a single pair as an argument.

\begin{kite}
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry = |f| -> {
  |p| -> {
    match p {
      (a, b) -> f(a,b)
    }
  }
}
\end{kite}

We have chosen to include these two functions from \nameref{foundation}) in this section as they reflect an essential part of Kite and functional programming languages in general.

\subsubsection{Partial application}
An example of partial application is the function \code{increment}, which partially applies addition:

\begin{kite}
increment :: Int -> Int
increment = (1+)
\end{kite}

Increment can then be applied to an integer:

\begin{kite}
two = increment(1) ----> 2
\end{kite}

It should be noted that the addition operator, \code{+}, has type \code{a
  -> a -> a}. Thus, partial application yields \code{a -> a} and since
it is partially applied with an integer, the type of \code{increment}
becomes \code{Int -> Int}

\subsubsection{Error handling}
Kite supports exceptions using the keyword \code{panic}. Using \code{panic} will stop the execution.

An example of the \code{panic} function in use:
\begin{kite}
  head :: [a] -> a
  head = |xs| -> {
    match xs {
      [] -> panic ("can't take head of empty list"),
      x,xs -> x
    }
  }
\end{kite}
If a user tries to take the head of an empty list, the execution of Kite will stop and the error message will be shown.


\subsection{Foundation}
As mentioned earlier in the \nameref{sec:requirements}, the \code{Foundation} of Kite is a standard library implemented in Kite consisting of often used functions. Kite's Foundation is inspired by Haskell's \code{Prelude}, and includes many functions found in
Prelude. 

Below are two examples from Foundation.
\subsubsection{List concatenation}
List concatenation does as the name suggests, namely concatenating two lists into a single list:

\begin{kite}
{++} :: [a] -> [a] -> [a]
{++} = |l, r| -> {
  match l {
    [] -> r,
    x,xs -> x : (xs ++ r)
  }
}
\end{kite}

For example, as strings are simply lists of characters, \code{++} can be used as follows:

\begin{kite}
"Hello," ++ " World!" ----> "Hello, World!"
\end{kite}

\subsubsection{List indexing}
Lists in Kite are zero-indexed, meaning that the first element of a list it at 'index' zero. Indexing a list retrieves the $n$-th element (starting from 0) of a list:

\begin{kite}
{#} :: [a] -> Int -> a
{#} = |xs, idx| -> {
  match xs {
    [] -> panic ("list index too large"),
    x,xs -> if idx == 0 then x else xs # (idx - 1)
  }
}
\end{kite}

A simple example of list indexing is as follows:

\begin{kite}
teens = range(13,19)
sweetSixteen = teens # 3 ----> 16
\end{kite}

For a full documentation of Foundation, please see
\nameref{foundation}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
