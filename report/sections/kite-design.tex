We have been inspired by many other languages when designing and
implementing Kite, most notably the GHC Haskell compiler\footnote{The
  Glasgow Haskell Compiler \url{http://www.haskell.org/ghc}}.


\subsection{Syntax and semantics}
In this section we will describe how to use the different features of Kite and how they work, i.e. the syntax and semantics.

TODO: Describe the panic-function

TODO: describe types, more on function declaration.

TODO: Parameterless functions, implicit return, blocks

\subsubsection{Basic types and declarations}

Basic declaration of the variables in Kite, types are inferred by the analyzer:
\begin{kite}

one = 1
two = 2.0
truth = True
list = [1, 2, 3, 4]
char = 'a'
pair = (1, 'a')
\end{kite}

The basic types will be Int, Float, Bool, Lists, Chars and
pairs.

Functional languages often make extensive use of lists, which is
indeed also the case for Kite. A list is an ordered array of items
that can be transformed in many different ways. We use a common
short-hand method for describing a list of things, using square
brackets $[\ ]$. For instance, a $List(Int)$ (pronounced ``List of
Ints'') is denoted $[Int]$ and a list of a type variables $a$ is
$[a]$. Lists can be nested, allowing $List(List(Int))$ denoted
$[[Int]]$.

The pair type is also abbreviated using $(,)$, for instance the type
$Pair(Int, Bool)$ is written $(Int, Bool)$

Strings is represented as syntactic sugar for lists of characters,
which will be discussed later.

Basic arithmetic operators in Kite and their us
\begin{kite}
two = 1 + 1  ---->  2
mod = 10 % 2 ---> 0
\end{kite}

\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation    & Meaning              \\ \hline
    x + y        & Additition           \\ \hline
    x - y        & Subtraction          \\ \hline
    x * y        & Multiplication       \\ \hline
    x / y        & Division             \\ \hline
    x**y         & Exponentiation       \\ \hline
    x \% m       & Remainder of x / y   \\ \hline
    pow(x, y, m) & Modulo exponentation \\ \hline
    \end{tabular}
\end{table}
Note: some operators will only work on certain types.

Basic boolean operators:
\begin{kite}
foo = 1 < 2  ----> True
bar = 1 == 2 ----> False
\end{kite}
Basic boolean operators include 
\begin{table}[H]
\centering
    \begin{tabular}{|l|l|}
    \hline
    Operation & Meaning                 \\ \hline
    $==$        & Equal                   \\ \hline
    $\backslash=$        & Not equal               \\ \hline
    $<=$        & Less than or equal than \\ \hline
    $>=$        & Greater than or equal   \\ \hline
    $<$         & Less than               \\ \hline
    $>$         & Greater than            \\ \hline
    \end{tabular}
\end{table}

A single basic bitwise operator:
\begin{kite}
10 ^ 8 ----> 2
\end{kite}
Kite only includes xor bitwise operator as of now.

\subsubsection{Function declaration}

Every function in Kite is declared as an anonymous function:
\begin{kite}
  
|ArgName, ... | -> { ... }
\end{kite}

Since everything in Kite is an expression, functions is simply a
variable bound to a given anonymous function. A function is declared
as follows:
\begin{kite}
function :: ArgType -> ... -> ReturnType
function = |ArgName, ... | -> { ... }
\end{kite}
Example of valid function declaration in Kite, taking one parameter of
the type Int and returning an Int.
\begin{kite}
foo :: Int -> Int
foo = |a| -> {
  a + 1
}
\end{kite}
A runnable program must always include the `main' function, which will be called once when the emitted code is run by Node.js:
\begin{kite}
  
main = -> { ... }
\end{kite}

In order to use the preprocessor to include another code file, use the \texttt{\#include} keyword:
\begin{kite}
  
#include "foo.kite"
\end{kite}

\subsubsection{Syntactic sugar}
\label{sec:kite-design-sugar}

By using a sugaring module, Kite will be able to express certain
functions more clearly and readable. Syntactic sugar includes infix
operators, multiple parameters on function calls, list of characters
as strings and list comprehensions.
Infix operators will allow infix use of certain functions in Kite. An
example of infix operators is the basic + arithmetic operation:
\begin{kite}
  
foo = 1 + 2
\end{kite}

Where the desugared version of the same expression is given as:

\begin{kite}
foo = ((+) (1)) (2)
\end{kite}

As Kite functions will only take one parameter, sugaring of multiple
parameter functions (or currying, see currying in \ref{subsubsec:currying})
will allow the usage of multiple parameter functions. Example of usage
of multiple parameters:
\begin{kite}
foo :: a -> a -> a
foo = |a, b| -> {
  a + b
}
\end{kite}

Which will be syntactic sugar for the following code:
\begin{kite}
foo :: a -> a -> a
foo = |a| -> {
  return |b| -> {
    return ((+) (a)) (b)
  }
}
\end{kite}

\textbf{Parameterless functions} are also syntactic sugar. For instance the main function is often declared as follows:

\begin{kite}
main = -> 
{
  ...
}
\end{kite}

and this is simply shorthand for

\begin{kite}
main = |Void| -> 
{
  ...
}
\end{kite}

\textbf{Strings} are syntactic sugar for list of characters, $List(Char)$,
which will allow for easier representations of character lists. An
example of a string is as follows:
\begin{kite}
  
str = "Hello"
\end{kite}

Where the corresponding desugar (note the distinction between strings
using double-quite (") and characters using single-quite (') will be:
\begin{kite}
  
str = ['H', 'e', 'l', 'l', 'o']
\end{kite}


\label{sec:ex-listcomp}
\textbf{List comprehensions} are syntactic sugar for manipulating
lists. An example of a list comprehension is as follows:
\begin{kite}
  
list = [ x*y | x <- range(3,5), y <- range(4,6) | (x+y) >= 10, y > 4]
\end{kite}
where the desugared version of the given example, will look as follows:
\begin{kite}
list =
flatMap(|x| -> {
  flatMap (|y| -> {
    if (|x,y| -> {y > 4})(x,y) && (|x,y| -> {(x+y) >= 10})(x,y)
       then [(|x,y| -> {x*y})(x,y)]
       else []
  } , range(4,6) )
}, range(3,5) )
\end{kite}
Take note that list comprehensions uses functions defined in the
foundation, which will be discussed later

\subsubsection{Recursion}

We have implemented recursion, and examples hereof are in the following where we also show pattern matching.

\subsubsection{Conditionals}

Kite features two conditional expressions, the if-expression and pattern matching.



The \textbf{if-expression} is not to be confused with an if-statement, as our implementation is not a control flow statement. It will always return an expression, and the return-types of the consequent and alternative must be the same.


\begin{kite}
if BoolExpression then Expression else Expression
\end{kite}

A more advanced form of conditional is \textbf{pattern matching}. It works by matching an expression to a list of cases, which can be either a normal expression or it can be a destructuring of a list or a pair.

Below we show the matching of `n' on 0, which is an expression, and `otherwise', which is written `\_':
\begin{kite}
fibo :: a -> b -> Int -> a
fibo = |a, b, n| -> {
    match n {
    0 -> a,
    _ -> fibo(b, (a + b), (n - 1))
    }
}
\end{kite}

An example of pattern matching on lists is our implementation of the function `reverse' \ref{foundation}, which matches `xs' with an expression, the empty list, and the head and tail of `xs':

\begin{kite}
reverse = |xs| -> {
  match xs {
    []    -> [],
    x,xs  -> reverse (xs) ++ [x]
  }
}

\end{kite}

The final case is matching on pairs. The example below shows our implementation of the function `fst' (first):
\begin{kite}
fst :: (a, b) -> a
fst = |p| -> {
  match p {
    (a , b) -> a
  }
}
\end{kite}

\subsubsection{High order functions (HoF)}
Kite features HoF, and the map-function is an example hereof. It takes a function and applies to every element of a list and returns the modified list:

\begin{kite}
map :: (a -> b) -> [a] -> [b]
map = |f, ls| -> {
  match ls {
    [] -> [],
    x,xs -> f (x) : map (f, xs)
  }
}
\end{kite}

\subsubsection{Currying}
\label{subsubsec:currying}
Besides every function in Kite is curried\footnote{Which should be fairly easy to see when looking at the type-declarations of the functions}, we have also implemented a curry (and uncurry) function, which given a function with a single pair as the argument, returns the same function taking two arguments corresponding to the values of the pair:

\begin{kite}
curry :: ((a, b) -> c) -> (a -> b -> c)
curry = |f| -> {
  |a,b| -> {
    f((a,b))
  }       
}
\end{kite}

Uncurry naturally does the opposite, meaning it takes a function taking two parameters and returns the same taking a single pair as an argument.

\begin{kite}
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry = |f| -> {
  |p| -> {
    match p {
      (a, b) -> f(a,b)
    }         
  } 
}
\end{kite}

We have chosen to include these two functions from \nameref{foundation}) in this section as they reflect an essential part of Kite and functional programming languages in general.

\subsubsection{Partial application}

An example of partial application is the function `increment', which partially applies addition:

\begin{kite}
increment :: Int -> Int
increment = (1+)
\end{kite}

Increment can then be applied to an integer:

\begin{kite}
  
two = increment(1) ----> 2
\end{kite}


It should be noted that the addition operator, `+', has type \code{a -> a -> a}. Thus partial application yields \code{a -> a} and since it is partially applied with an integer, the type of \code{increment} becomes \code{Int -> Int}

\subsection{Foundation}

As mentioned earlier in the report (TODO - ref!), the `Foundation' of Kite is a standard library implemented in Kite consisting of often used functions. Kite's Foundation is inspired by Haskell's `Prelude', and includes many functions found in
Prelude. 

TODO: MORE FUN FUN FUN

Below are two examples from Foundation.
\subsubsection{List concatenation}

List concatenation does as the name suggests, namely concatenating two lists into a single one:
\begin{kite}
{++} :: [a] -> [a] -> [a]
{++} = |l, r| -> {
  match l {
    [] -> r,
    x,xs -> x : (xs ++ r)
  }
}
\end{kite}

For example, as strings are simply lists of characters, \code{++} can be used as follows:

\begin{kite}
"Hello," ++ " World!" ----> "Hello, World!"
\end{kite}

\subsubsection{List indexing}

List indexing retrieves the n'th element\footnote{Starting from 0, meaning Kite uses 0-indexing} of a list:
\begin{kite}
{#} :: [a] -> Int -> a
{#} = |xs, idx| -> {
  match xs {
    [] -> panic ("list index too large"),
    x,xs -> if idx == 0 then x else xs # (idx - 1)
  }
}
\end{kite}


A simple example of list indexing is as follows:

\begin{kite}
teens = range(13,19)
sweetSixteen = teens # 3 ----> 16
\end{kite}



For the rest of the documentation of Foundation, please see \nameref{foundation}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
